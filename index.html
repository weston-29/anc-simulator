<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Noise Cancellation Simulator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Schibsted+Grotesk:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>

    <!-- Event Listener for rendering LaTeX equation via KaTeX package -->
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Schibsted Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
            background: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .value-display {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 700;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #764ba2;
            transform: scale(1.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        .help-text {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
        }
        
        .button-container {
            text-align: center;
            margin-bottom: 30px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeaa7;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .metric-value {
            font-size: 2em;
            font-weight: 700;
        }
        
        .charts {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .charts.visible {
            display: grid;
        }
        
        .chart-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.1em;
        }
        
        @media (max-width: 768px) {
            .charts {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
        }
        
        .info-section {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #667eea;
        }
        
        .info-section h3 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .info-section p {
            color: #555;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Active Noise Cancellation Simulator</h1>
        <p class="subtitle">Explore how active noise cancellation works by adjusting distances and DSP parameters!</p>
        
        <div class="controls">
            <div class="control-group">
                <label>
                    Step Size (μ)
                    <span class="value-display" id="muValue">0.01</span>
                </label>
                <input type="range" id="muSlider" min="0.001" max="0.1" step="0.001" value="0.01">
                <span class="help-text">Controls how quickly the algorithm learns. <br><br> In practical terms, how much the weight vector impacts each update step.</span>
            </div>
            
            <div class="control-group">
                <label>
                    Filter Length
                    <span class="value-display" id="filterValue">64</span>
                </label>
                <input type="range" id="filterSlider" min="16" max="256" step="16" value="64">
                <span class="help-text">How much 'memory' the filter has when trying to cancel sound. <br><br> In practical terms, the length of the weight vector.</span>
            </div>
            
            <div class="control-group">
                <label>
                    Processing Delay (samples)
                    <span class="value-display" id="procDelayValue">5</span>
                </label>
                <input type="range" id="procDelaySlider" min="1" max="20" step="1" value="5">
                <span class="help-text">Simulates real-world DSP latency. <br><br> If this exceeds mic-to-ear delay, the system becomes non-causal and fails.</span>
            </div>
            
            <div class="control-group">
                <label>
                    Mic-to-Ear Delay (samples)
                    <span class="value-display" id="micDelayValue">10</span>
                </label>
                <input type="range" id="micDelaySlider" min="1" max="30" step="1" value="10">
                <span class="help-text">Simulates distance between reference mic and ear. <br><br> The time sound takes to get across this gap is when all the computation happens!</span>
            </div>
        </div>
        
        <div class="button-container">
            <button onclick="runSimulation()">▶ Run Simulation</button>
        </div>
        
        <div id="status" class="status" style="display: none;"></div>
        
        <div class="metrics" id="metrics" style="display: none;">
            <div class="metric-card">
                <div class="metric-label">Noise Reduction</div>
                <div class="metric-value" id="noiseReduction">--</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Available Time</div>
                <div class="metric-value" id="availableTime">--</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">System Status</div>
                <div class="metric-value" id="systemStatus">--</div>
            </div>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <div class="chart-title">Noise vs Anti-Noise Signal</div>
                <canvas id="signalChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Residual After Cancellation</div>
                <canvas id="residualChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Convergence (RMS Error)</div>
                <canvas id="convergenceChart"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">Frequency Spectrum</div>
                <canvas id="spectrumChart"></canvas>
            </div>
        </div>
        
        <style>
        .button-container {
            text-align: center;
            margin-top: 10px;
        }
    </style>

    <div class="info-section">
        <h3>About This Simulator</h3>
        <p id="infoText">
            If you've tried the new AirPods 4 with ANC, you may have been impressed by how much background noise they removed, despite creating no physical seal in your ear.<span id="dots">...</span><span id="moreText" style="display: none;"> <br><br><strong>Active noise cancellation (ANC)</strong> began in the 1930s when <em>Paul Lueg</em> proposed "anti-sound," a theoretical method of using soundwaves with the exact opposite physical properties of background noise that would 'cancel each other out.' <em>Harry Olson</em> proved this theory experimentally at RCA in the early 1950s. In 1959, <em>Stanford professor Bernt Widrow</em> and his student Marcian "Ted" Hoff created adaptive filtering and <strong>the least-mean-squares (LMS) algorithm</strong> - an early version of what this simulation uses, giving ANC the adaptive learning brain it needed. Since then, engineers at Southampton and Bose have adapted ANC to work on tiny processors found in devices like FAA-certified pilot headsets (1989), Bose QuietComfort headphones (2000), and Apple's AirPods Pro (2019). Use this simulation to explore how changing parameters of the <em>digital signal processing (DSP)</em> and physical orientation of microphones changes the efficacy of the anti-noise!<br><br>
        </p>
        <div class="button-container">
            <span id="readMoreBtn" style="color: #999; font-size: 0.9em; cursor: pointer; display: inline-block; transition: all 0.2s;" onmouseover="this.style.fontSize='0.95em'; this.style.color='#667eea';" onmouseout="this.style.fontSize='0.9em'; this.style.color='#999';" onclick="toggleReadMore()">(click for more)</span>
        </div>
    </div>

    <script>
    function toggleReadMore() {
        const dots = document.getElementById('dots');
        const moreText = document.getElementById('moreText');
        const btnText = document.getElementById('readMoreBtn');
        
        if (dots.style.display === 'none') {
            dots.style.display = 'inline';
            moreText.style.display = 'none';
            btnText.textContent = '(click for more)';
        } else {
            dots.style.display = 'none';
            moreText.style.display = 'inline';
            btnText.textContent = '(click for less)';
        }
    }
    </script>
        
        <div style="text-align: center; margin-top: 40px; padding: 30px; background: #f8f9fa; border-radius: 15px; border: 2px solid #667eea;">
            <h3 style="color: #333; margin-bottom: 20px;">NLMS Weight Update Equation</h3>
            <p style="color: #555; font-size: 1em; line-height: 1.6; margin-bottom: 20px; max-width: 900px; margin-left: auto; margin-right: auto;">
                The Least-Means-Squared (LMS) algorithm updates the sound cancellation filter weights proportionally to any residual error noise that sneaks through the initial filtering. This creates a feedback loop where the anti-noise signal gradually learns to match the original noise, as both sounds evolve.
            </p>
            <div style="font-size: 1.3em; margin: 20px 0;">
                $w(n+1) = w(n) + \frac{\mu}{\alpha + ||x(n)||^2} e(n) x(n)$
            </div>
            <p style="margin-top: 15px; color: #666; font-size: 0.95em;">
                Where <strong>w(n)</strong> = filter weights, <strong>μ</strong> = step size, <strong>α</strong> = regularization constant,<br>
                <strong>||x(n)||²</strong> = input signal power, <strong>e(n)</strong> = error signal, <strong>x(n)</strong> = reference signal
            </p>
        </div>

        <div style="text-align: center; margin-top: 30px; padding: 30px; background: #f8f9fa; border-radius: 15px; border: 2px solid #667eea;">
            <h3 style="color: #333; margin-bottom: 20px;">Further Reading</h3>
            <div style="text-align: left; max-width: 800px; margin: 0 auto; line-height: 2;">
                <p style="margin: 10px 0;">
                    ✍︎ <a href="https://patentimages.storage.googleapis.com/97/93/fc/19408ed05d22d6/US2043416.pdf" target="_blank" style="color: #667eea; text-decoration: none; font-weight: 500; border-bottom: 2px solid transparent; transition: border-bottom 0.2s;" onmouseover="this.style.borderBottom='2px solid #667eea'" onmouseout="this.style.borderBottom='2px solid transparent'">Paul Lueg's Original 1936 Patent for Sound Wave Cancellation</a>
                </p>
                <p style="margin: 10px 0;">
                    ✍︎ <a href="https://pubs.aip.org/asa/jasa/article/25/6/1130/747326/Electronic-Sound-Absorber" target="_blank" style="color: #667eea; text-decoration: none; font-weight: 500; border-bottom: 2px solid transparent; transition: border-bottom 0.2s;" onmouseover="this.style.borderBottom='2px solid #667eea'" onmouseout="this.style.borderBottom='2px solid transparent'">Olson and May 1953 - Experimental Demos of Sound Absorption @ RCA Labs</a>
                </p>
                <p style="margin: 10px 0;">
                    ✍︎ <a href="https://www-isl.stanford.edu/~widrow/papers/c1960adaptiveswitching.pdf" target="_blank" style="color: #667eea; text-decoration: none; font-weight: 500; border-bottom: 2px solid transparent; transition: border-bottom 0.2s;" onmouseover="this.style.borderBottom='2px solid #667eea'" onmouseout="this.style.borderBottom='2px solid transparent'">Widrow and Hoff 1960 - The Algorithmic Ancestor of the Modern (N)LMS Weight Update Algorithms</a>
                </p>
                <p style="margin: 10px 0;">
                    ✍︎ <a href="https://www.mathworks.com/help/audio/ug/active-noise-control-with-simulink.html" target="_blank" style="color: #667eea; text-decoration: none; font-weight: 500; border-bottom: 2px solid transparent; transition: border-bottom 0.2s;" onmouseover="this.style.borderBottom='2px solid #667eea'" onmouseout="this.style.borderBottom='2px solid transparent'">A Cool Tutorial To Build Your Own Physical ANC Experiment using MATLAB, Speakers, and some PVC!</a>
                </p>
            </div>
        </div>
        
    </div>

     <script>
        // Update slider value displays with gradient colors
        function updateSliderDisplay(sliderId, displayId, min, max, forward = true) {
            const slider = document.getElementById(sliderId);
            const display = document.getElementById(displayId);
            
            slider.oninput = function() {
                const value = parseFloat(this.value);
                const percentage = (value - min) / (max - min);
                
                // Blue to Red gradient
                let r, b;
                if (forward) {
                    r = Math.round(percentage * 255);
                    b = Math.round((1 - percentage) * 255);
                } else {
                    b = Math.round(percentage * 255);
                    r = Math.round((1 - percentage) * 255);
                }
                const color = `rgb(${r}, 0, ${b})`;
                
                display.style.background = color;
                
                // Update text
                if (sliderId === 'muSlider') {
                    display.textContent = value.toFixed(3);
                } else {
                    display.textContent = value;
                }
            };
        }
        
        // Initialize all sliders
        updateSliderDisplay('muSlider', 'muValue', 0.001, 0.1);
        updateSliderDisplay('filterSlider', 'filterValue', 16, 256);
        updateSliderDisplay('procDelaySlider', 'procDelayValue', 1, 20);
        updateSliderDisplay('micDelaySlider', 'micDelayValue', 1, 30, false);

        let charts = {};

        function generateNoise(length, fs) {
            const t = Array.from({length}, (_, i) => i / fs);
            const noise = new Array(length);
            
            for (let i = 0; i < length; i++) {
                noise[i] = 
                    0.5 * Math.sin(2 * Math.PI * 100 * t[i]) +
                    0.3 * Math.sin(2 * Math.PI * 250 * t[i]) +
                    0.2 * Math.sin(2 * Math.PI * 400 * t[i] + Math.PI/4) +
                    0.15 * (Math.random() - 0.5) * 2;
            }
            
            return noise;
        }

        function runNLMS(noise, params) {
            const {filterLength, mu, alpha, refToEarDelay, processingDelay} = params;
            const n_samples = noise.length;
            const speakerToEarDelay = 2;
            const systemDelay = processingDelay + speakerToEarDelay;
            
            let w = new Array(filterLength).fill(0);
            const antiNoise = new Array(n_samples).fill(0);
            const errorSignal = new Array(n_samples).fill(0);
            const residualNoise = new Array(n_samples).fill(0);
            
            const maxDelay = Math.max(refToEarDelay, systemDelay) + filterLength;
            const xBuffer = new Array(maxDelay).fill(0);
            const yBuffer = new Array(Math.max(systemDelay, 1)).fill(0);
            
            const delayCompensation = refToEarDelay - systemDelay;
            
            for (let n = 0; n < n_samples; n++) {
                xBuffer.unshift(noise[n]);
                xBuffer.pop();
                
                const x = new Array(filterLength);
                const startIdx = Math.max(0, delayCompensation);
                for (let i = 0; i < filterLength; i++) {
                    x[i] = xBuffer[startIdx + filterLength - 1 - i];
                }
                
                let y = 0;
                for (let i = 0; i < filterLength; i++) {
                    y += w[i] * x[i];
                }
                
                yBuffer.unshift(y);
                yBuffer.pop();
                antiNoise[n] = y;
                
                const noiseAtEar = n >= refToEarDelay ? noise[n - refToEarDelay] : 0;
                const antiNoiseAtEar = systemDelay > 0 ? yBuffer[yBuffer.length - 1] : y;
                
                const e = noiseAtEar - antiNoiseAtEar;
                errorSignal[n] = e;
                residualNoise[n] = e;
                
                if (n >= Math.max(filterLength, refToEarDelay, systemDelay)) {
                    let xPower = 0;
                    for (let i = 0; i < filterLength; i++) {
                        xPower += x[i] * x[i];
                    }
                    
                    let step = mu / (alpha + xPower);
                    step = Math.min(step, 0.1);
                    
                    for (let i = 0; i < filterLength; i++) {
                        w[i] += step * e * x[i];
                    }
                    
                    let wNorm = 0;
                    for (let i = 0; i < filterLength; i++) {
                        wNorm += w[i] * w[i];
                    }
                    wNorm = Math.sqrt(wNorm);
                    
                    if (wNorm > 10) {
                        const scale = 10 / wNorm;
                        for (let i = 0; i < filterLength; i++) {
                            w[i] *= scale;
                        }
                    }
                }
            }
            
            return {antiNoise, errorSignal, residualNoise};
        }

        function calculateRMS(signal, start = 0) {
            let sum = 0;
            for (let i = start; i < signal.length; i++) {
                sum += signal[i] * signal[i];
            }
            return Math.sqrt(sum / (signal.length - start));
        }

        function fft(signal) {
            const n = signal.length;
            const spectrum = new Array(Math.floor(n/2));
            
            for (let k = 0; k < Math.floor(n/2); k++) {
                let real = 0;
                let imag = 0;
                for (let t = 0; t < n; t++) {
                    const angle = -2 * Math.PI * k * t / n;
                    real += signal[t] * Math.cos(angle);
                    imag += signal[t] * Math.sin(angle);
                }
                spectrum[k] = Math.sqrt(real * real + imag * imag);
            }
            
            return spectrum;
        }

        function runSimulation() {
            const mu = parseFloat(document.getElementById('muSlider').value);
            const filterLength = parseInt(document.getElementById('filterSlider').value);
            const processingDelay = parseInt(document.getElementById('procDelaySlider').value);
            const refToEarDelay = parseInt(document.getElementById('micDelaySlider').value);
            
            const fs = 8000;
            const duration = 2.0;
            const n_samples = Math.floor(duration * fs);
            
            const noise = generateNoise(n_samples, fs);
            const params = {
                filterLength,
                mu,
                alpha: 0.1,
                refToEarDelay,
                processingDelay
            };
            
            const speakerToEarDelay = 2;
            const systemDelay = processingDelay + speakerToEarDelay;
            const isCausal = systemDelay <= refToEarDelay;
            const availableTimeMs = ((refToEarDelay - systemDelay) / fs * 1000).toFixed(2);
            
            // Update status
            const statusDiv = document.getElementById('status');
            statusDiv.style.display = 'block';
            
            if (isCausal) {
                statusDiv.className = 'status success';
                statusDiv.innerHTML = `✓ System is CAUSAL - ANC should work!<br>Available processing time: ${availableTimeMs}ms`;
            } else {
                statusDiv.className = 'status error';
                statusDiv.innerHTML = `⚠ System is NON-CAUSAL! Anti-noise arrives ${Math.abs(parseFloat(availableTimeMs))}ms LATE.<br>Reduce processing delay or increase mic-to-ear distance!`;
            }
            
            const {antiNoise, errorSignal, residualNoise} = runNLMS(noise, params);
            
            const convergencePoint = Math.max(filterLength, refToEarDelay, systemDelay) + 1000;
            const originalRMS = calculateRMS(noise, convergencePoint);
            const residualRMS = calculateRMS(residualNoise, convergencePoint);
            const noiseReductionDB = 10 * Math.log10(originalRMS / (residualRMS + 1e-10));
            
            // Update metrics
            document.getElementById('metrics').style.display = 'grid';
            document.getElementById('noiseReduction').textContent = noiseReductionDB.toFixed(1) + ' dB';
            document.getElementById('availableTime').textContent = availableTimeMs + ' ms';
            document.getElementById('systemStatus').textContent = isCausal ? '✓' : '✗';
            
            // Show charts on first run
            document.querySelector('.charts').classList.add('visible');
            
            updateCharts(noise, antiNoise, residualNoise, errorSignal, fs);
        }

        function updateCharts(noise, antiNoise, residualNoise, errorSignal, fs) {
            const startSample = Math.floor(0.5 * fs);
            const endSample = Math.floor(0.55 * fs);
            const displayLength = endSample - startSample;
            
            const timeAxis = Array.from({length: displayLength}, (_, i) => ((startSample + i) / fs * 1000).toFixed(1));
            
            // Signal Chart
            if (charts.signal) charts.signal.destroy();
            charts.signal = new Chart(document.getElementById('signalChart'), {
                type: 'line',
                data: {
                    labels: timeAxis,
                    datasets: [{
                        label: 'Original Noise',
                        data: noise.slice(startSample, endSample),
                        borderColor: 'rgb(54, 162, 235)',
                        borderWidth: 2,
                        pointRadius: 0,
                    }, {
                        label: 'Anti-Noise (inverted)',
                        data: antiNoise.slice(startSample, endSample).map(x => -x),
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        pointRadius: 0,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { title: { display: true, text: 'Time (ms)' }},
                        y: { title: { display: true, text: 'Amplitude' }}
                    },
                    plugins: { legend: { display: true }}
                }
            });
            
            // Residual Chart
            if (charts.residual) charts.residual.destroy();
            charts.residual = new Chart(document.getElementById('residualChart'), {
                type: 'line',
                data: {
                    labels: timeAxis,
                    datasets: [{
                        label: 'Original',
                        data: noise.slice(startSample, endSample),
                        borderColor: 'rgba(54, 162, 235, 0.3)',
                        borderWidth: 1,
                        pointRadius: 0,
                    }, {
                        label: 'Residual',
                        data: residualNoise.slice(startSample, endSample),
                        borderColor: 'rgb(75, 192, 192)',
                        borderWidth: 2,
                        pointRadius: 0,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { title: { display: true, text: 'Time (ms)' }},
                        y: { title: { display: true, text: 'Amplitude' }}
                    },
                    plugins: { legend: { display: true }}
                }
            });
            
            // Convergence Chart
            const windowSize = 100;
            const rmsError = [];
            const rmsTimeAxis = [];
            for (let i = windowSize; i < errorSignal.length; i += 50) {
                let sum = 0;
                for (let j = i - windowSize; j < i; j++) {
                    sum += errorSignal[j] * errorSignal[j];
                }
                rmsError.push(Math.sqrt(sum / windowSize));
                rmsTimeAxis.push((i / fs).toFixed(2));
            }
            
            if (charts.convergence) charts.convergence.destroy();
            charts.convergence = new Chart(document.getElementById('convergenceChart'), {
                type: 'line',
                data: {
                    labels: rmsTimeAxis,
                    datasets: [{
                        label: 'RMS Error',
                        data: rmsError,
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true,
                        backgroundColor: 'rgba(255, 99, 132, 0.1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { title: { display: true, text: 'Time (s)' }},
                        y: { title: { display: true, text: 'RMS Error' }, beginAtZero: true }
                    },
                    plugins: { legend: { display: false }}
                }
            });
            
            // Spectrum Chart
            const noiseSpectrum = fft(noise.slice(0, 2048));
            const residualSpectrum = fft(residualNoise.slice(0, 2048));
            const freqAxis = Array.from({length: noiseSpectrum.length}, (_, i) => i * fs / 2048);
            
            if (charts.spectrum) charts.spectrum.destroy();
            charts.spectrum = new Chart(document.getElementById('spectrumChart'), {
                type: 'line',
                data: {
                    labels: freqAxis.slice(0, 200),
                    datasets: [{
                        label: 'Original Noise',
                        data: noiseSpectrum.slice(0, 200),
                        borderColor: 'rgb(54, 162, 235)',
                        borderWidth: 2,
                        pointRadius: 0,
                    }, {
                        label: 'Residual Noise',
                        data: residualSpectrum.slice(0, 200),
                        borderColor: 'rgb(75, 192, 192)',
                        borderWidth: 2,
                        pointRadius: 0,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: { title: { display: true, text: 'Frequency (Hz)' }},
                        y: { type: 'logarithmic', title: { display: true, text: 'Magnitude (log)' }}
                    },
                    plugins: { legend: { display: true }}
                }
            });
        }
    </script>
</body>
</html>
